---
title: "EDS 223: Week 3"
format: html
editor_options: 
  chunk_output_type: console
---

# Setup

Load all necessary packages
```{r}
library(sf)
library(tmap)
library(tidyverse)
library(spData)
```

Read in data
```{r}
nz <- spData::nz
nz_height <- spData::nz_height
```

```{r}
# First filter to the region of Canterbury
canterbury <- nz |>
  filter(Name == "Canterbury")

# Take a look
tm_shape(nz) +
  tm_polygons() +
  tm_shape(canterbury) +
  tm_fill(col = "darkgrey") +
  tm_shape(nz_height) +
  tm_dots(col = "red")
```

# Spatial subsetting (filtering)

```{r}
# Simple bracket subsetting
c_height1 <- nz_height[canterbury, ]

# By default bracket subsetting will filter to features in x that intersect features in y. However, we can use other topological relationships by changing options:
# nz_height[canterbury, , op = st_disjoint]

# Can also do this the "tidy way" with st_filter
c_height2 <- nz_height |>
  st_filter(y = canterbury, .predicate = st_intersects)

# Create a logical vector based on st_intersects (output = sparse binary predicate list)
nz_height_sgbp <- st_intersects(x = nz_height, y = canterbury)
nz_height_logical <- lengths(nz_height_sgbp) > 0
c_height3 <- nz_height[nz_height_logical,]
```

# Distance relationships

```{r}
# Find heights within 1000 km of Canterbury
nz_height_logical <- st_is_within_distance(nz_height, canterbury,
                      dist = units::set_units(1000, "km"),  # set distance
                      sparse = FALSE)  # return logical vector instead
c_height4 <- nz_height[nz_height_logical, ]  # filter based on logical
```

# Spatial joins

```{r}
st_join(nz_height, nz, join = st_intersects) |>
  select(id = t50_fid, elevation, region = Name) |> # clean some things up by selecting some cols and renaming
  group_by(region) |>
  summarise(n_points = n()) |>
  st_drop_geometry()  # to make things pretty, like if you wanted to make a nice table (think HW)
```

# Distance based joins
```{r}
# Load in some more data
cycle_hire <- spData::cycle_hire
cycle_hire_osm <- spData::cycle_hire_osm

# Take a look
tmap_mode("view")

tm_shape(cycle_hire) +
  tm_symbols(col = "red", alpha = 0.2) +
  tm_shape(cycle_hire_osm) +
  tm_symbols(col = "blue", alpha = 0.2)
```

```{r}
cycle_hire_join <- st_join(cycle_hire, cycle_hire_osm,
        st_is_within_distance,
        dist = units::set_units(20, "m"))
```

```{r}
# Write a check
if(nrow(cycle_hire) == nrow(cycle_hire_join)) {
  print("Join matches original data dimensions")
} else{
  warning("Join does not match original data dimensions")
  print(paste("cycle_hire has", nrow(cycle_hire), "rows"))
  print(paste("cycle_hire_join has", nrow(cycle_hire_join), "rows"))
}
```

# Geometry operations
## Aggregating
```{r}
# load US states
us_states <- spData::us_states

# summarize total population within each region
regions <- us_states |>
  group_by(REGION) |>
  summarise(population = sum(total_pop_15, na.rm = TRUE))

tmap_mode("plot")
tm_shape(us_states) +
  tm_polygons()

tm_shape(regions) +
  tm_polygons()
```

```{r}
# combine geometries of western states
us_west <- us_states[us_states$REGION == "West", ]
us_west_union <- st_union(us_west)

# combine geometries of Texas and western states
texas <- us_states[us_states$NAME == "Texas", ]
texas_union <- st_union(us_west_union, texas)
tm_shape(texas_union) +
  tm_polygons()
```

## Buffering
```{r}
# In this example, letâ€™s create 5 km buffer around the Seine.
seine <- spData::seine
seine_buffer <- st_buffer(seine, dist = 50000)

seine_union <- st_union(seine_buffer)

tm_shape(seine_union) +
  tm_polygons() +
tm_shape(seine) +
  tm_lines()
```

```{r}
nz_height_buffer <- st_buffer(nz_height, dist = 1000000)

# same as st_filter with st_is_within_distance
c_height5 <- nz_height_buffer |>
  st_filter(y = canterbury, .predicate = st_intersects)

# check!
if(nrow(c_height4) == nrow(c_height5)) {
  print("results matched")
} else {
  warning("results do not match")
}
```

## Clipping
```{r}
# for example, lets create some geometries
x <- st_sfc(st_point(c(0, 1))) |>
  st_buffer(, dist = 1) |>
  st_as_sf()

y <- st_sfc(st_point(c(1, 1))) |>
  st_buffer(, dist = 1) |>
  st_as_sf()\

intersection <- st_intersection(x, y)
difference_x_y <- st_difference(x, y)
difference_y_x <- st_difference(y, x)
sym_difference <- st_sym_difference(x, y)

bbox <- st_union(x,y)

tm_shape(x, bbox = bbox) +
  tm_borders(col = "red") +
  tm_shape(y) +
  tm_borders(col = "blue") +
  tm_shape(sym_difference) +
  tm_fill(col  = "purple")
  
```

```{r}
bb <- bbox
box <- st_as_sf(bb)
p <- st_sample(x = box, size = 100) |>  # create random points on a surface
  st_as_sf()

x_and_y <- st_intersection(x, y)

p_xy1 <- p[x_and_y, ]
p_xy2 <- p %>%
  st_filter(., x_and_y)

tm_shape(x, bbox = bbox) +
  tm_borders(col = "red") +
  tm_shape(y) +
  tm_borders(col = "blue") +
  tm_shape(p_xy2) +
  tm_dots()
```

## Centroids

```{r}
nz_centroid <- st_centroid(nz)  # find the centroid (issue, sometimes not actually on the surface of interest)
nz_pos <- st_point_on_surface(nz)  # find a "centroid-esk" object thats restricted to the geometry, or surface of interest

tm_shape(nz) +
  tm_polygons() +
  tm_shape(nz_centroid) +
  tm_symbols(col = "red", alpha = 0.5) +
  tm_shape(nz_pos) +
  tm_symbols(col = "blue", alpha = 0.5)
```

## Simplification

```{r}
seine_simple <- st_simplify(seine, dTolerance = 2000)

tm_shape(seine_simple) +
  tm_lines()
```





